package org.firstinspires.ftc.teamcode.lib

import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.util.Size
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry
import com.qualcomm.robotcore.hardware.Gamepad
import com.qualcomm.robotcore.hardware.HardwareMap
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName
import org.firstinspires.ftc.robotcore.internal.camera.calibration.CameraCalibration
import org.firstinspires.ftc.vision.VisionPortal
import org.firstinspires.ftc.vision.VisionProcessor
import org.opencv.core.Core
import org.opencv.core.CvType
import org.opencv.core.Mat
import org.opencv.core.MatOfPoint
import org.opencv.core.Point
import org.opencv.core.Rect
import org.opencv.core.Scalar
import org.opencv.imgproc.Imgproc
import java.util.LinkedList



/**
 * @param centerCamFactor .5 is middle, increase (0-1) to make left side detection area larger
 */
class TargetPositionGetter(hardwareMap: HardwareMap, color: VisionProc.Color, val centerInLeft: Boolean = false, val centerCamFactor: Double = 0.5) {
    val width = 640
    class VisionProc(val color: Color, val centerCamFactor: Double) : VisionProcessor {
        override fun init(width: Int, height: Int, calibration: CameraCalibration?) {
        }
        enum class Color {
            RED, BLUE, YELLOW, GREEN
        }

        var size = -1
        var tele: MultipleTelemetry? = null
        var hierarchyOutput = Mat()
        //var hsvMat = Mat()
        var thresholdMat = Mat()
        var currentDetection : Rect? = null
        var contours: List<MatOfPoint> = LinkedList()
        var sensitivity = 10.0
        override fun processFrame(frame: Mat?, captureTimeNanos: Long): Rect? {
            try {
                contours = LinkedList()

                thresholdMat = Mat.zeros(frame!!.size(), CvType.CV_8U)
                var out = Mat()
                var hsvMat = Mat()
                Imgproc.cvtColor(frame, hsvMat, Imgproc.COLOR_RGB2HSV)
                if (color == Color.BLUE) {//Colors generated by Copilot
                    // Detect blue color
                    Core.inRange(
                        hsvMat,
                        Scalar(100.0, 100.0, 100.0),
                        Scalar(140.0, 255.0, 255.0),
                        out
                    )
                } else if (Color.RED == color) {
                    // Detect red color
                    var lowRed = Mat()
                    var highRed = Mat()
                    Core.inRange(
                        hsvMat,
                        Scalar(0.0, 100.0, 100.0),
                        Scalar(10.0, 255.0, 255.0),
                        lowRed
                    )
                    Core.inRange(
                        hsvMat,
                        Scalar(160.0, 100.0, 100.0),
                        Scalar(180.0, 255.0, 255.0),
                        highRed
                    )
                    Core.add(lowRed, highRed, out)
                } else if (Color.YELLOW == color) {
                    // Detect yellow color
                    Core.inRange(
                        hsvMat,
                        Scalar(20.0, 100.0, 100.0),
                        Scalar(30.0, 255.0, 255.0),
                        out
                    )
                } else if (Color.GREEN == color) {
                    // Detect green color
                    Core.inRange(
                        hsvMat,
                        Scalar(40.0, 100.0, 100.0),
                        Scalar(80.0, 255.0, 255.0),
                        out
                    )
                }

                Imgproc.findContours(
                    out,
                    contours,
                    hierarchyOutput,
                    Imgproc.RETR_TREE,
                    Imgproc.CHAIN_APPROX_SIMPLE
                )

                val boundRects = arrayOfNulls<Rect>(contours.size)
                contours.forEachIndexed { i, contour ->
                    boundRects[i] = Imgproc.boundingRect(contour)
                }

                Imgproc.drawContours(frame, contours, -1, Scalar(255.0, 0.0, 0.0), 2)

                var largestCont: MatOfPoint? = null
                var largestContArea = 0

                for (cont in contours) {
                    val area = cont.toList().size
                    if (area > largestContArea) {
                        largestCont = cont
                        largestContArea = area
                    }
                }
                if (largestCont != null) {
                    var x1 = Double.MAX_VALUE//find lowest
                    var y1 = Double.MAX_VALUE
                    var x2 = Double.MIN_VALUE//find highest
                    var y2 = Double.MIN_VALUE
                    for (point in largestCont.toList()) {
                        if (point.x < x1) {
                            x1 = point.x
                        }
                        if (point.y < y1) {
                            x2 = point.x
                        }
                        if (point.x > x2) {
                            x2 = point.x
                        }
                        if (point.y > y2) {
                            y2 = point.y
                        }
                    }
                    currentDetection = Rect(x1.toInt(), y1.toInt(), (x2 - x1).toInt(), (y2 - y1).toInt())
                    size = largestContArea
                    var x = 640*centerCamFactor
                    Imgproc.line(frame, Point(x, 0.0), Point(x, 480.0), Scalar(0.0, 255.0, 0.0, 255.0), 5)
                    x = (currentDetection!!.x + currentDetection!!.width/2).toDouble()
                    Imgproc.line(frame, Point(x, 0.0), Point(x, 480.0), Scalar(0.0, 0.0, 255.0, 255.0), 5)
                    Imgproc.rectangle(frame, currentDetection!!, Scalar(0.0, 255.0, 255.0, 255.0), 5)
                }
                return currentDetection
            } catch (e: Exception) {
                e.printStackTrace()
                throw java.lang.Exception(e.toString() + "||" + e.stackTraceToString())
            }
        }

        override fun onDrawFrame(
            canvas: Canvas?,
            onscreenWidth: Int,
            onscreenHeight: Int,
            scaleBmpPxToCanvasPx: Float,
            scaleCanvasDensity: Float,
            userContext: Any?
        ) {
            val p = Paint()
            p.color = android.graphics.Color.MAGENTA
            val l = currentDetection
            if (l != null && canvas != null) {
                canvas.drawRoundRect(l.x.toFloat(), l.y.toFloat(), l.x.toFloat() + l.width.toFloat(), l.y.toFloat() + l.height.toFloat(), 1.0F, 1.0F, p)
            }
        }

    }
    val proc = VisionProc(color, centerCamFactor)
    val visionPortal = VisionPortal.Builder()
        .setCamera(hardwareMap.get(WebcamName::class.java, "Webcam 1"))
        .addProcessor(proc)
        .setCameraResolution(Size(width, 480))
        .setStreamFormat(VisionPortal.StreamFormat.MJPEG)
        .enableLiveView(true)
        //.setCamera
        .setAutoStopLiveView(true)
        .build();
    init {
        visionPortal.setProcessorEnabled(proc, true)
        //fully enable vision portal on Driver Hub
    }
    //fun pos
    private var leftDetections = 0
    private var rightDetections = 0
    private var centerDetections = 0
    enum class LCR {
        Left,
        Center,
        Right;
        fun reverse() = when (this) {
            Left -> Right
            Center -> this//uses less memory :)
            Right -> Left
        }
    }
    fun lcr() : LCR = if (leftDetections >= rightDetections && leftDetections >= centerDetections) {
            LCR.Left
        } else if (centerDetections >= leftDetections && centerDetections >= rightDetections) {
            LCR.Center
        } else {
            LCR.Right
        }

    /**
     * deal with bad data, 7500 ms is subject to change
     */
    fun doDetect(telemetry: MultipleTelemetry) : LCR {
        val time = System.currentTimeMillis() + 1500
        while (System.currentTimeMillis() < time) {
            telemetry(MultipleTelemetry(), false)
        }
        telemetry.addData("LCR", lcr())
        telemetry.addData("LCRDetectionsLeft=", leftDetections)
        telemetry.addData("LCRDetectionsCenter=", centerDetections)
        telemetry.addData("LCRDetectionsRight=", rightDetections)
        return lcr()
    }
    fun telemetry(telemetry: MultipleTelemetry, doing: Boolean) {
        proc.tele = telemetry
        telemetry.addData("RectSize", proc.size)
        if (proc.currentDetection != null && proc.size > 150) {
            telemetry.addData("Rect", proc.currentDetection!!.toString())
            val cd = proc.currentDetection!!
            val x = cd.x + cd.width/2
            val centerLine = width*centerCamFactor
            if (!centerInLeft) {
                //c is cam, f is fov limit
                // f-- --     f
                //|       |
                //|       |
                //       c
                if (x < centerLine) {
                    centerDetections++
                    telemetry.addData("Direction", "Center")
                } else if (x > centerLine) {
                    rightDetections++
                    telemetry.addData("Direction", "Right")
                } else {
                    leftDetections++
                    telemetry.addData("Direction", "Left")
                }
            } else {
            //f     -- --f
                //|       |
                //|       |
                // c
                if (x < centerLine) {
                    leftDetections++
                    telemetry.addData("Direction", "Left")
                } else if (x > centerLine) {
                    centerDetections++
                    telemetry.addData("Direction", "Center")
                } else {
                    rightDetections++
                    telemetry.addData("Direction", "Right")
                }
            }
        } else {
            telemetry.addData("Direction", "NONE")
        }
        telemetry.addData("Rect", proc.currentDetection)

        telemetry.update()
    }

    fun close() {
        //Idk how to do this if you have any ideas put them here
    }
}